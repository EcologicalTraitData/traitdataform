---
title: "vignette of package 'traitdataform'"
author: "Florian D. Schneider"
date: "26 Juni 2017"
output: html_document
---


This vignette contains step-by step instructions for transferring own data into a standardized trait-dataset for upload to public databases. The output object uses the trait data standard put forward in the Whitepaper (refer to pub). 

## step 1 reading in data

First, load your own data into R, preferrably in a matrix, table or longtable format (See notes on different data formats of trait data). 

You may rename the column names of the original file to match the column names described in the trait data standard, but this howto also describes a mapping of the column names along the process of data handling. 

R knows many ways of getting your original data into an R object. In most cases you would read an object from a csv or txt file while maintaining the column headers. 

```{r}

library(traitdataform)

inputdata1 <- read.csv("../../example_data/Orthoptera_MelanieChiste_flucAssym.csv")
inputdata2 <- read.csv("../../example_data/Moths_Traits_Sagrario.csv")
inputdata3 <- read.csv("../../example_data/moth_traits_jule.csv")
inputdata4 <- read.table("../../example_data/carabid traits final (Fons).txt", header = TRUE)
inputdata5 <- read.table("../../example_data/18987.txt", header = TRUE)
inputdata6 <- read.csv("../../example_data/ArthropodSpeciesTraits.csv")

```

## step 2 transfer into longtable format

As explained in the whitepaper, most trait data are stored in a species--trait matrix format or a table with replicated measurements of multiple individuals.

- **species-trait matrix data** :  a single account of a trait value for each species (in rows) for a couple of different traits (in columns). No replicates of species are reported. This is the most likely format for literature data, where average values or facts for entire species have been collated into a single lookup table. 
- **occurence table** : In this case, your data report one or several raw measurements (in columns) taken from a single occurence of a species, i.e. an individual specimen (in rows). Repeated measures of the same trait might also be included as columns or pooled into average values. This is most common for measured data and is valuable for investigations of intra-specific variation. 

Additional information on the reported value may be stored in further colums (e.g. the unit in which a value is reported or the literature source for this measurement or fact), or in a separate data sheet linked via identifiers for specimen, trait, taxon, or sampling/measurement event. Examples below will explain how these information can be added to the data sheet.

For a standardisation of trait data for use in databases, we highly recommend a longtable format, where each row comprises the reporting of a single measurement or fact, linked to a trait definition as well as a valid taxon name, and optionally to other layers of information.

The function `as.traitdata()`  provided in the package assist in transferring own data into the longtable format. For this function to work, it needs to know about the columns of the original data that contain trait values (parameter `traits`), and the column which contains the taxonomic specification (parameter `taxa`).

```{r}

out1 <- as.traitdata(inputdata1,
              traits = c("length1", "body_length", "pronl1", "pronl2", "pronw1", "pronw2", "ov1", "ov2", "femurleft1", "femurright1", "femurleft2", "femurright2", "forewingleft1", "forewingright1", "forewingleft2", "forewingright2"),
              taxa = "spec"
              )
head(out1)

```

Note that in the output table the columns have been named after the traitdata standard proposed in the whitepaper (ref). The essential columns are `traitName`, `traitValue` for the reported measurement or fact as well as  `ScientificName` for the taxon assignment. In case of occurence table data, an occurenceID is provided automatically, or can be provided by the author using the parameter `occurences` (as a column name or a vector of occurence IDs). In case of a species-trait-matrix, no occurence IDs are assigned. 

```{r}

out1 <- as.traitdata(inputdata1,
              traits = c("length1", "body_length", "pronl1", "pronl2", "pronw1", "pronw2", "ov1", "ov2", "femurleft1", "femurright1", "femurleft2", "femurright2", "forewingleft1", "forewingright1", "forewingleft2", "forewingright2"),
              taxa = "spec",
              occurences = "nr"
              )

subset(out1, occurenceID == "772" ) # show different trait measurements for same occurence/individual

```

### case example: provide measurement unit 

For a standardisation of quantitative trait data, the unit of measurement is essential. Often, this information is kept in the metadata descriptions. But for a standardised scheme, this information should always accompany the measurement value. A common way to provide the unit is adding another column to your original data table containing the unit in an unambiguous format. 
The function `as.traittable()` assists in adding the units. 

This can be done for all traits in a single stroke (if all reported values refer to the same unit) or to each trait specifically (if they used different measuremnt units or if the table comprises a mixture of quantitative and qualitative traits).  

The syntax for this uses the parameter `units`, which takes a single character string, or a vector of character strings, containing valid entries as expected  by the package 'units' (Pebesma et al. 2016, https://github.com/edzer/units/, v0.4-5, Examples are 'mm', 'm2' or 'm^2', 'm/s'). 

```{r}
out1 <- as.traitdata(inputdata1,
              traits = c("length1", "body_length", "pronl1", "pronl2", "pronw1", "pronw2", "ov1", "ov2", "femurleft1", "femurright1", "femurleft2", "femurright2", "forewingleft1", "forewingright1", "forewingleft2", "forewingright2"),
              taxa = "spec", 
              occurences = "nr",
              units = "mm"
              )
head(out1)
```

A character vector should have the same length as the provided vector of trait names (in parameter `traits`), or otherwise should be a named vector of the form `c(trait1 = "mm", trait2 = "mm2")`, where only the traits contained in the vector names will receive units while the others will remain blank. 

```{r}

out2 <- as.traitdata(inputdata2,
                      traits = c("Fl.period", "Specialisation", "Gen.per.year", "Wingspan.med"),
                      taxa = "Species", 
                      units = c(Wingspan.med = "mm")
)
head(subset(out2, traitName == "Wingspan.med"))


out6 <- as.traitdata(inputdata6, 
                      traits = c("Body_Size", "Dispersal_ability", "Feeding_guild_short", "Feeding_mode", "Feeding_specialization", "Feeding_tissue", "Feeding_plant_part", "Endophagous_lifestyle", "Stratum_use_short"),
                      taxa = "SpeciesID",
                      units = c("mm", "unitless", "", "","", "", "", "", "" ))
head(out6)
```

Logical or factorial traits ususally don't come with a unit. In mixed data, the field should specify as empty, `""` or as`NA`. 

### case example: raw data are coded as numeric factor levels 

The data table should be human readable, thus you may consider translation into true factorial data via function `factor()`. 
This may not be useful if the numeric levels correspond to fine grained distinctions that cannot be translated into short factor levels. 
A translation into factorials is even ill-adviced if factor levels are ordinal, i.e. they correspond to a sequence of logically ordered levels and the ordering would be lost by translating into alphabetically ordered factorials. In this case, provide a definition of factor levels in the metadata description of variables or in an accompanying dataset containing trait definitions.

```{r}

inputdata3$hibernation <- factor(inputdata3$hibernation, levels = c(1,2,3,4), labels = c("egg", "larva", "pupa", "adult"))
inputdata3$feeding_niche <- factor(inputdata3$feeding_niche, levels = c(1,2,3,4), labels = c("narrow_specialist", "moderate_specialist", "moderate_generalist", "wide_generalist"))

out3 <- as.traitdata(inputdata3,
                      traits = c("size", "feeding_niche", "hibernation", "voltinism", "grassland", "dispersion", "cold_adapt", "warm_adapt", "endangered"),
                      taxa = "Name"
                      )

head(subset(out3, traitName == "feeding_niche"))
head(subset(out3, traitName == "hibernation"))

```


### case example: keep additional data columns

The raw data might contain further information on the specimen or the trait measurement itself in further data columns that are valuable for later analysis. This can be for instance data about the sex or developmental stage of the individual, the sampling or preservation method of the specimen, or the conditions under which the measurement was taken. 

The parameter `keep` allows you to specify which columns contain valuable information as a character vector. As a negative version of `keep`, specifying `drop` would allow you to name the columns that are not valueable, while all others will be kept. Not specifying `keep` or `drop` will result in dropping all columns except the core measurement and identifier columns.  


```{r}

out1 <- as.traitdata(inputdata1,
              traits = c("length1", "body_length", "pronl1", "pronl2", "pronw1", "pronw2", "ov1", "ov2", "femurleft1", "femurright1", "femurleft2", "femurright2", "forewingleft1", "forewingright1", "forewingleft2", "forewingright2"),
              taxa = "spec", 
              occurence = "nr",
              units = c(rep("mm", 12), rep("mm2", 4)),
              keep = c("bz",  "EP", "sex", "age", "name")
              )
head(out1)

```

The traitdata standard (whitepaper) suggests standard names for many of these extra information, which might fall into the domain of the extensions for occurence or measurementOrFact (see below). We highly reccomend mapping the columns provided into these standard names by using the rename feature of the `as.traitdata()` function. This is simply acheived by providing a named vector for `keep` that uses the compatible column names as vector names.  

```{r}

out1 <- as.traitdata(inputdata1,
              traits = c("length1", "body_length", "pronl1", "pronl2", "pronw1", "pronw2", "ov1", "ov2", "femurleft1", "femurright1", "femurleft2", "femurright2", "forewingleft1", "forewingright1", "forewingleft2", "forewingright2"),
              taxa = "spec", 
              occurence = "nr",
              units = c(rep("mm", 12), rep("mm2", 4)),
              keep = c("bz", locationID = "EP", sex = "sex", age =  "age", measurementDeterminedBy = "name")
              )

head(out1)

```

Note that a lack of a name in the named vector maintains the original name. Note also, that no checking for valid column names (as compared to the traitdata glossary) is performed at this stage. This is to ensure that the raw data table created by `as.traittable()` can contain any columns that the author considers relevant. The `keep` parameter can be used to rename columns into intuitive column names. 


### case example: adding further information on traits, species or single measurements

Beyond measurement units, further information might be available that are not recorded in the raw data table, but are related to the trait type, the taxon, the individual or specimen, or to the reported fact, measurement or sampling event. 

In most cases those information are kept in seperate data sheets of your file, e.g. the place were a specimen has been sampled or the literature source from where a species value has been cited. In this case, a unique identifier might link to this other datasheet, such as a number for each individual occurence of a specimen (`occurenceID`) or a identifier for a single measurement or reported fact (`measurementID`). 

The trait data standard described in the whitepaper provides two extensions of the namespace that should be used to describe these data:

- the `occurence` extension contains information on the level of individual specimens, such as date and location and method of sampling and preservation, or physiological specifications of the phenotype, such as sex, life stage or age. 
- the `measurementOrFact` extension takes information at the level of single measurements or reported values, such as the original literature from where the value is cited, the method of measurement or statistical method of aggregation. 

The extensions are compatible with Darwin Core Standard and EOL TraitBank.  

You may decide to keep the information in a seperate data sheet. In that case, the traitdata table should at least contain a column with the respective identifier that directs to the covariate datasheet. The identifier might also take the format of a globally valid URI or API call.

It is however recommended to add these information directly as own columns within the data table to enable an analysis of cofactors and correlations further down the road. This way, if datasets of different source are merged, the information is readily available without the risk of breaking the reference to an external datasheet. 

The function `as.traittable()` provides a set of parameters to add information at the different levels. The following three examples will illustrate how to add covariates to each occurence or  measurement.  The principle is always the same: A unique identifier for these levels of information can be associated with a vector or data table containing the additional information, which will then be merged into the data table. 

<!-- TODO: add functionality -->

#### Adding information on specimen level (occurence Extension)

#### Adding information on measurement or fact (measurementOrFact Extension)

## step 3 map to standardised column names 

Step 1 and 2 produced a tidy and correctly formatted version of your own trait data. We now turn to the challenging task of standardisation. 

At first, we will make sure that the columns are mapped to the column names expected by the trait data standard. The definitions and standard column names are given in the glossary of terms provided at http://fdschneider.de/bexis_traits/traitdatastandard.html. 

A detailled description of these terms is provided in our traits whitepaper. 

<!--If you were following the previous steps, the use of function `as.traitdata()` already ensured that the core data columns are corresponding to standard column names (`measurementValue`, `measurementUnit`, `taxonName`, `traitName`, `specimenID`, `measurementID`). -->

The mapping process done by the function `mapping()` assists in renaming any data table into the columns expected by the traitdata standard and checks for compliance.
Plain output of function `as.traitdata()` already has the correct column names for the core columns and needs not be treated by mapping.

Run `mapping()` on your data table with a named vector as the second parameter to provide the user-defined columns until no warning message remains: 

```{r}
out1mapped <- mapping(out1, replace = c(bz = "locationID", locationID = "ExploratoriesPlotID"))
head(out1mapped)
```

Using mapping to produce compliant data is optional. You also may provide a table that uses compliant column names in the first place. However, mapping checks that no column names are misspelled and fields are filled with valid entries. 

The dataset resulting from this step is already compliant with the traitdata standard. However, for making your data better comparable to other traitdata sets, step 4 will transfer the core data columns into harmonized and referenced data. 

For further steps of processing, a  correct use of column names is obligatory! 

## step 4 standardise taxon names and trait values

Two aspects of trait data need thorough standardisation: the names of species and higher taxa need to be mapped to globally accepted definitions and the names of traits should be referenced to unambiguous definitions and, where possible, translated to standard units and accepted factor levels. 

### taxon name standardisation

For taxon name standardisation, the function `standardize.taxonomy()` makes use of fuzzy matching algorithms provided by the package 'taxize' to match the entries of column `scientificName` against the GBIF Backbone Taxonomy (taxize v). The result is written into a new column `scientificNameStd`. Additional columns comprise the order (for ambiguous names), the reported taxon rank, as well as a globally unique taxon ID which references the taxon to GBIF Backbone Taxonomy in a universal URI format.  

If further layers of taxonomic information are desired as an output, the function takes the parameter `return`, which by default contains `c("taxonID", "scientificNameStd", "order", "taxonRank")`. Other specifications can be added here. 

Note that for this to work, `scientificName` must contain a full account of the species name or higher taxon, no abbreviations (spaces or underscores are handled alright). 

Note also, that taxon name mapping requires an internet connection and might take some time, depending on the length of your species list. 

```{r, message=FALSE}
out1std <- standardize.taxonomy(out1)
head(out1std)

out2std <- standardize.taxonomy(out2, return = c("taxonID", "scientificNameStd", "rank", "order", "genus", "taxonRank"))
head(out2std)

out6std <- standardize.taxonomy(mapping(out6))
head(out6std)
```


### trait name and value standardisation

Due to the heterogeneity of approaches and research questions related to trait-based research, a universal trait standard does not exist. Therefore it is difficult to assign globally unique identifiers that provide a reference to an unambiguous definition. Some databases offer a list of traits in some way or another, e.g. via an API interface, but few offer a stable URI reference. For most cases, you would need to refer to an own lookup table or metadata using dataset specific identifiers. 

To transfer the user provided traits and trait values into standardised values, the function `standardize.traits()` merges the data table with this reference table to produce values of a compliant format. 

#### refer to an existing trait thesaurus

A couple of trait ontologies do exist, e.g. the TOP Thesaurus of plant traits (used by TRY) or Gramene.org offer definitions of plant traits via an API. For soil invertebrates, the T-SITA thesaurus offers a set of traits relevant for this organism group. To date, no script for a systematic access of these ontologies can be provided here. Thus, the key information must be provided manually as an own data object in R. 

This procedure is only recommended if *all* of the traits reported in your dataset refer to a definition  in an online thesaurus. 

```{r}

out4 <- as.traitdata(inputdata4,
                      traits = c("body_length", "antenna_length", "metafemur_length"),
                      taxa = "name_correct", 
                      units = "mm"
                      )
head(subset(out4))

out4tax <- standardize.taxonomy(out4)


#edit to use thesaurus
traits4 <- thesaurus(
                      traitName = c("body_length", "antenna_length", "metafemur_length"),
                      traitID = c("http://t-sita.cesab.org/BETSI_vizInfo.jsp?trait=Body_length", "http://t-sita.cesab.org/BETSI_vizInfo.jsp?trait=Antenna_length", ""), 
                      valueType = c("numeric"),
                      traitUnit = c("mm", "mm", "mm") )

out4tra <- standardize.traits(out4, traits4)

```

We highly encourage the implementation of APIs for these online glossaries, which would allow a looking up existing trait definitions programmatically in the future. 

#### refer to an own trait list

For an interim solution, until comprehensive trait ontologies are compiled, your dataset should therefore be referenced to a publicly available dataset or file that specifies the trait in detail. Ideally it is stored as an asset along with your trait dataset. This can be a csv or txt file published on a open access repository (figshare, researchgate or github, to name but a few), or a website providing direct links to the trait definition (URI). 

The reference file should contain at least the following columns: 

- `traitName` should be a short descriptive name. No spaces should be used. Rather use a scheme with underscore or capital letters to highlight multiple words (e.g. 'body_length' or 'bodyLenght').  
- `traitID` should specify an alphanumeric ID for the specific use in your dataset or - better - a URI that reliably links to the definition of the trait measurement on an online repository. This could be achieved by providing a online version of your traitlist (TODO: provide instructions in wiki how to achieve this). We highly encourage to submit your own trait definitions to existing ontology servers to facilitate this process of trait standardisation (e.g. with GFBio). 
- `traitDescription`: a detailled and unambiguous, human readable definition.
- `valueType` to specify the expected kind of entries. Set it to 'numeric' for quantitative traits, 'integer' for counts or ordinal traits, 'character' for trait values that are provided as free text, 'factor' for traits that take one of few non-ordinal levels, 'logical' for binary/boolean entries (yes/no).  
- For *numeric traits*, the field `traitUnit` should provide the expected unit for the trait. The R script will then try to convert trait values into this unit. 
- for *categorical traits* of kind 'factor' or 'integer', the field `factorLevels` should contain a list the valid factorial traits separated by semicolon. In case of ordinal traits, the order must be precisely corresponding to the number of possible integer values. 
- `Comments` may contain examples and clarifications

Further Columns can be added to specify the trait definition in relation to other current or outdated definitions or to set a version number

- `Refines` would link the trait definition to an existing ontology on the web. Ideally this contains a URI.  
- `Reference` would contain a original literature reference where the trait measurement has been described. 
- `Version`
- `DateIssued`
- `DateModified`
- `Replaces`

The trait thesaurus can be created from a csv or txt-file using the function `thesaurus()`. The parameter `replace` can be used for fixing column names to the expected names outlined above (see function `rename()` of the reshape package). 

```{r}
traits1 <- thesaurus(read.csv("../docs/traitlist_arthropods.csv"), replace = c(measurementType = "traitName", measurementTypeDescription = "traitDescription", measurementTypeID = "traitID", measurementValueType = "valueType") )

head(traits1)

```

Alternatively, the thesaurus can be created manually by providing named vectors for the function `thesaurus()` which will be used to create a valid data frame. This is especially useful if your data comprise only a small number of traits.


```{r}
traits2 <- thesaurus(
  traitID = paste0("mothtrait", 1:4),
  traitName = c("flightPeriod", "specialisation", "GenerationsPerYear", "wingspanMedian"),
  traitDescription = c("length of flight period in months", "degree of specialisation: 1) wide generalist, 2) moderate generalist, 3) moderate specialist, 4) strict specialist", "number of reproductive cycles per year on average", "stretched wingspan in mm"), 
  valueType = c("numeric", "integer", "integer", "numeric"), 
  traitUnit = c("months","","","cm") 
  )

traits2


traits6 <- thesaurus(
  traitID = paste0("A", 1:9),
  traitName = c("Body_Size", "Dispersal_ability", "Feeding_guild_short", "Feeding_mode", "Feeding_specialization", "Feeding_tissue", "Feeding_plant_part", "Endophagous_lifestyle", "Stratum_use_short"),
  valueType = c("numeric", "numeric", "factor", "factor", "factor", "factor", "factor", "factor", "factor"), 
  factorLevels = c("", "", "predator; detritivore; fungivore; herbivore; omnivore", "chewing; extraintestinal; sucking", "monophagous; oligophagous; polyphagous", "", "", "", "" ),
  traitUnit = c("cm","unitless","","","","","","","") 
  )

traits6

```

As with a data.frame, if providing a parameter of shorter length as the others, the vector will be recycled. In case of homogeneous quantitative traits, this allows for instance to enter a universal unit that applies to all traits likewise. 

#### providing the thesaurus to standardise trait data

The function `standardize.traits()` now finally has all it needs to complete its job. 

```{r, meassage = FALSE}

out2taxtrt <- standardize.traits(out2std, traits2, map = c(Wingspan.med = "wingspanMedian", Fl.period = "flightPeriod", Gen.per.year = "GenerationsPerYear", Specialisation = "specialisation"))

head(subset(out2taxtrt, traitNameStd == "wingspanMedian" ))

write.csv(out2std, file = "traits_.csv")

```

What does the function do in terms of standardisation. 

- **Unit conversion**: on all numerical traits, unit conversion to the target unit will be attempted. Unit conversion can only be successfully performed if both columns `traitUnit` and `traitUnitStd` are provided with valid unit names for the numeric trait.
- **factor level checking** : if a controlled vocabulary is provided in the trait thesaurus, the function checks whether the provided factor levels are valid and asks for a mapping vector otherwise. 
- **logical value harmonization** : for logical traits, the function harmonizes the standardised output. By default it produces a vector of TRUE and FALSE entries. Missing values return NA. The parameters `output` and `categories` can be provided to function `standardize()`. See `?fixlogical` for further detail. 

In case the traitnames of the thesaurus and the trait names of the original data are not the same, a named mapping vector can be provided to translate the user provided traits to the traits in the thesaurus. 

Note that multiple traits can be mapped to the same output trait, e.g. if the original trait names refer to left and right wing but now are to be pooled into the same trait. For use on the authors side, the original naming will be preserved in the column `traitName_original`. 

```{r, meassage = FALSE}

out4taxtra <- standardize.traits(out4tax, traits4)
head(out4taxtra)

write.csv(out4taxtra, file = "traits_standardized.csv", map = )

```

#### two-in-one standardization

To make things even simpler, the two functions for standardization are wrapped into one named `standardize()`. A single call will do, taking all the optional parameters described above. 

```{r, meassage = FALSE}
out6taxtra <- standardize(out6, traits6)

```




## single-line command

The functions described here are applied sequentially. The output of the first step can be piped into the second step, etc. Therefore it is possible to run the functions in an automated fashion, if all necessary parameters for the intermediate steps are provided.  

```{r, meassage = FALSE}
standardize(read.csv("../example_data/Orthoptera_MelanieChiste_flucAssym.csv"), 
            traits = , 
            taxa = , 
            units = , 
            thesaurus = , 
            map = , 
            replace = , 
            )
```

